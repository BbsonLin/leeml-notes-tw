# 誤差(Error)從哪裡來的?

![](res/chapter5-1.png)

從 Chapter 3 的測試資料來看，`Average error` 會隨著模型複雜度增加呈上升趨勢，表示更複雜的模型並不能給測試資料帶來更好的預測效果。

而這些 `error` 的主要來源有兩種，分別是 `bias(偏差)` 和 `variance(變異數 或 方差)`。

<!-- 然而 $bias$ 和 $variance$ 是什么？可以查看 [机器学习中的Bias(偏差)，Error(误差)，和Variance(方差)有什么区别和联系？](https://www.zhihu.com/question/27068705) -->

## 估測(Estimation)

假設真實的函數為 $\hat f$，但是這函數只有 Niamtic 公司才知道。

![](res/chapter5-2.png)

所以我們只能透過蒐集寶可夢資料，然後透過 Chapter3 Step1 ~ Step3 來訓練我們的假想模型，並得出我們的理想函數集 $f^*$，但 $f^*$ 不過只是我們針對 $\hat f$ 的預估。

![](res/chapter5-3.png)

這過程像是打靶，$\hat f$ 是靶心，$f^*$ 是我們射擊的結果。

如上圖，$\hat f$ 與 $f^*$ 之間的差距就是 `bias` 加上 `variance` 所導致的。


### 統計學中的估測

可以從統計學的例子來理解上述估測中的 `bias` + `variance`。

#### 估測 $x$ 的算數平均

假設 $x$ 的算數平均為 $\mu$，變異數(方差)為 $\sigma^2$

在統計學中，要如何估測算數平均呢?

- 首先拿到 $N$ 個樣本：$\{x^1,x^2,···,x^N\}$
- 計算樣本的算數平均 $m$, 此時 $m=\frac{1}{N}\sum_n x^n \neq \mu$
- 接著計算很多組的 $m$，然後求 $m$ 的期望值：$E[m]=E[\frac{1}{N}\sum x^n]=\frac{1}{N}\sum_nE[x^n]=\mu$

![](res/chapter5-4.png)

這種估測方式稱為無偏差估測(Unbiased Estimator)

$m$ 分布對於 $\mu$ 的離散程度取決於變異數：$Var[m]=\frac{\sigma^2}{N}$

可以看得出 $N$ 越大，離散程度越小(如下圖)

![](res/chapter5-5.png)

#### 估測 $x$ 的變異數(方差)

在來看統計學中，要如何估測變異數(方差)呢?

- 同樣首先拿到 $N$ 個樣本：$\{x^1,x^2,···,x^N\}$
- 利用前一小節估測出來的 $m$，計算出樣本變異數: $s^2=\frac{1}{N}\sum_n (x^n-m)^2$
- 計算很多組 $s^2$ 的期望值: $E[s^2]=\frac{N-1}{N}\sigma^2$

由期望值可推得出 $s^2$ 出現小於 $\sigma^2$ 的次數會相對較多。

所以理論上 $N$ 愈大時 $s^2$ 估測出來的值會越接近 $\sigma^2$。(如下圖)

![](res/chapter5-6.png)

--

接下來，我們看回到機器學習中估測出來的 `bias` + `variance`。

![](res/chapter5-7.png)

我們要估測的是靶心 $\hat f$；接著我們蒐集了好幾次資料，而他們落在 $f^*$ 這些藍點位置。

於是乎我們可以算這些 $f^*$ 的期望值：$E[f^*] = \bar f$

> $\bar f$ 與靶心(也就是 $\hat f$)偏移了一段誤差(error)，我們稱作 `bias`。

以打靶為例，就是你以為靶心在 $\bar f$ 的位置，但其實不然，導致你瞄靶的時候就沒有瞄準，這中間的誤差(error)就是 `bias(偏差)`。

> 另外一個誤差(error)，我們可以看到每個藍點(每個 $f^*$)都會離 $\bar f$ 的位置又再偏差一些位置，而這個稱作 `variance`。

又以打靶為例，因為可能槍枝的不同，每次打出的子彈都可能有些許的不同，這中間的誤差(error)就是 `variance`。

以上就能知道誤差從哪來的呢?  
有可能來自兩個地方一個是 `bias`，另一個則是 `variance`。


### 怎麼做出不同的模型呢?


讨论系列02中的案例：这里假设是在平行宇宙中，抓了不同的神奇宝贝

![](res/chapter5-8.png)

用同一个model，在不同的训练集中找到的 $f^∗$ 就是不一样的

![](res/chapter5-9.png)

这就像在靶心上射击，进行了很多组（一组多次）。现在需要知道它的散布是怎样的，将100个宇宙中的model画出来

![](res/chapter5-10.png)

不同的数据集之前什么都有可能发生—||


#### 考虑不同模型的方差

一次模型的方差就比较小的，也就是是比较集中，离散程度较小。而5次模型的方差就比较大，同理散布比较广，离散程度较大。

所以用比较简单的模型，方差是比较小的（就像射击的时候每次的时候，每次射击的设置都集中在一个比较小的区域内）。如果用了复杂的模型，方差就很大，散布比较开。

这也是因为简单的模型受到不同训练集的影响是比较小的。

#### 考虑不同模型的偏差

![](res/chapter5-11.png)

这里没办法知道真正的 $\hat{f}$，所以假设图中的那条黑色曲线为真正的 $\hat{f}$

结果可视化，一次平均的 $\bar{f}$ 没有5次的好，虽然5次的整体结果离散程度很高。



一次模型的偏差比较大，而复杂的5次模型，偏差就比较小。

直观的解释：简单的模型函数集的space比较小，所以可能space里面就没有包含靶心，肯定射不中。而复杂的模型函数集的space比较大，可能就包含的靶心，只是没有办法找到确切的靶心在哪，但足够多的，就可能得到真正的 f¯f¯。


#### 偏差v.s.方差

![](res/chapter5-12.png)

将系列02中的误差拆分为偏差和方差。简单模型（左边）是偏差比较大造成的误差，这种情况叫做欠拟合，而复杂模型（右边）是方差过大造成的误差，这种情况叫做过拟合。

## 怎么判断？

### 分析

![](res/chapter5-13.png)

如果模型没有很好的训练训练集，就是偏差过大，也就是欠拟合
如果模型很好的训练训练集，即再训练集上得到很小的错误，但在测试集上得到大的错误，这意味着模型可能是方差比较大，就是过拟合。
对于欠拟合和过拟合，是用不同的方式来处理的

#### 偏差大-欠拟合

此时应该重新设计模型。因为之前的函数集里面可能根本没有包含$f^*$。可以：


将更多的函数加进去，比如考虑高度重量，或者HP值等等。
或者考虑更多次幂、更复杂的模型。
如果此时强行再收集更多的data去训练，这是没有什么帮助的，因为设计的函数集本身就不好，再找更多的训练集也不会更好。

#### 方差大-过拟合

简单粗暴的方法：更多的数据

![](res/chapter5-14.png)

但是很多时候不一定能做到收集更多的data。可以针对对问题的理解对数据集做调整。比如识别手写数字的时候，偏转角度的数据集不够，那就将正常的数据集左转15度，右转15度，类似这样的处理。

## 模型选择



现在在偏差和方差之间就需要一个权衡
想选择的模型，可以平衡偏差和方差产生的错误，使得总错误最小
但是下面这件事最好不要做：

![](res/chapter5-15.png)

用训练集训练不同的模型，然后在测试集上比较错误，模型3的错误比较小，就认为模型3好。但实际上这只是你手上的测试集，真正完整的测试集并没有。比如在已有的测试集上错误是0.5，但有条件收集到更多的测试集后通常得到的错误都是大于0.5的。

### 交叉验证

![](res/chapter5-16.png)

图中public的测试集是已有的，private是没有的，不知道的。交叉验证 就是将训练集再分为两部分，一部分作为训练集，一部分作为验证集。用训练集训练模型，然后再验证集上比较，确实出最好的模型之后（比如模型3），再用全部的训练集训练模型3，然后再用public的测试集进行测试，此时一般得到的错误都是大一些的。不过此时会比较想再回去调一下参数，调整模型，让在public的测试集上更好，但不太推荐这样。（心里难受啊，大学数模的时候就回去调，来回痛苦折腾）

上述方法可能会担心将训练集拆分的时候分的效果比较差怎么办，可以用下面的方法。

### N-折交叉验证
将训练集分成N份，比如分成3份。

![](res/chapter5-17.png)

比如在三份中训练结果Average错误是模型1最好，再用全部训练集训练模型1。